//-----------------------------------------------------
// Common Header.

pub fn select(arg: &String) {
  match arg.as_ref() {
    "2a" => a(),
    "2b" => b(),
    "2" | "*" => {a(); b()},
    _ => ()
  }
}

//-----------------------------------------------------
// Setup.

static INPUT : &'static str = "UULDRRRDDLRLURUUURUURDRUURRDRRURUDRURRDLLDRRRDLRUDULLRDURLULRUUURLDDRURUDRULRDDDUDRDLDDRDDRUURURRDDRLRLUDLUURURLULLLRRDRLDRLRDLULULRDRDDUURUDRRURDLRRDDDLUULDURDLDLLRLRLLUDUDLRDDLUURUUDDRDULDDLDLLDULULRLDDDUDDDRLLRURLRDUUUDUUDDURRDLDDLRDLLUDDLDRLDULDRURLUUDLURLUDRULRLRUUUURLUUUDDULLRLLURDRURLLRLRLDDRURURULRULLUUUULUDULDDDRDDLURLUURRLDDRDRUDDRRLURRDURRLDUULRRLLRDLLDDUURULLRUURRRRDRRURLULLRLRDDULULRDLDDLULLD
UUDUDDRRURRUDDRLDLURURLRLLDRLULLUURLLURDRLLURLLRRLURDLDURUDRURURDLRDRRDULRLLLRDLULDRLLDLDRLDDRUUUUULRLDUURDUUUURUUDLRDLLDRLURULDURURLDLLRDLULLULLLLLUDUDDLRLLLUDLRUUDDUUDUDDDLULDDUDUULUUDUDRRULRRRURUDUUULDDRURLLULLULURLUDRDLUUUDLDRRLRRRULLRRURRUDDDRDLDDDLDUDLLDRRDURRURRURRLDLURUULRLDLUDUDUUULULUUDDDLDDULRDULLULDRDDURRURRRULRDURULUDURRDLLUURRUURLLLULDRRULUUUURLRLRDDDDULLUUUDRRLRRLRRLLLUDDDLRDDURURRDULLLUDLUDURRLRDURUURURDRDUUURURRUDRURRULLDDURRLRRRUULDRLDRRURUDLULRLLRRDLDDRLRRULDDLLUURUDDUDRLUD
DDDUDDRRDRRRUULDRULDLDLURRRUURULRUDDRLLLLURRLRULDLURRULDRUDRRLLLLDULRDLUUURDDLDLURRLLUUURLLUDLUDRRDDULLULURDULRRDLRLDRRUUUUDLRRDLDDLDULDRUULRLLDLRURRUDLDDDRUUULLDDLULDULDUURUDDDLULUDLUURLRURUURDDUDRRLDRRRDDDDRDLUDRRDURDLDRURDDDRRLLLRDDRRRDDLDRLLUURRLDRDDRDLRDDLLDRLRDRDDDURLULLRUURDLULRURRUUDLDRLDRRDDRLDDUULLRDDRRLLLDDDUURDUDRUDUDULDULRUURLDURRDLUURRDLLDDLLURUUUDRLUURRDLUDUULRURLUDDLLRUDURRDRRRDRDLULRRLRUDULUUDRLURRRRLULURRDLLDRDDRLULURDURRDUUULLRDUUDLDUDURUDRUDDLRLULRLRLRRRLRUULLDDLUDDLDRRRLDDLLRLRLRUDULRLLLUULLDRDLDRRDULLRRLLDLDUDULUDDUUDLRDRLUUULLRLDLDDLLRUDDRDD
DDUURRLULDLULULLDUDDRURDDRLRDULUURURRLURDLRRDUUDLULDRDLDLRLULLRULLDRLDRRULUDRLDURUURLLDLLDDLUULLRLRULRLUURDDDDDRLDRLLLDLULDLDLULRRURLLLLLLRLUDLRRLRULUULLLLURDLLRLLDDUDLLULDLLURUUDLRDRDUDDDRDDUULRLLDDDLLRLURLUDLULRRUUUULLDLDLLLDRLUDRDRDLUDLRUDRDRUDRDLLDDLRRLRDLDURDLDRUUUDRLULUULDURDLUUUDDDDDLDRDURDLULDDLLUDUURRUDDLURUDDLRLUUDURUDUULULUDLDLUURDULURURULDDDLUUUUDLUUDUDLLLRDDLRDDLRURRRLLLULLURULLRDLLDRULRDDULULRLUDRRRDULRLLUDUULLRDRDDDULULRURULDLDLDRDLDUDRDULLUUUUUDLRDURDUUULLLRUULLRUULDRRUUDLLLULLUURLDDLUULLRLRLRDRLLLRLURDDURUDUULULDLRLRLLUDURRURDRUDLRDLLRDDRDUULRDRLLRULLUDDRLDLDDDDUDRDD
URDLUDUDLULURUDRLUDLUDLRLRLLDDDDDLURURUURLRDUDLRRUUDUURDURUULDRRRDDDLDUURRRDLRULRRDLRUDUDLDDDLLLRLRLRUUUUUULURRRLRLUDULURLDLLDUUDDRUDLDUDRRLULLULLDURDDRRLLRLDLLLLRLULLDDDDLDULLRDUURDUDURRUULLDRULUDLUULUUDDLDDRDLULLULDLDRLDLRULLRLURDURUDRLDURDRULRLLLLURRURLRURUDUDRRUDUUDURDDRRDRLURLURRLDRRLLRLRUDLRLLRLDLDDRDLURLLDURUDDUUDRRLRUDLUDULDRUDDRDRDRURDLRLLRULDDURLUUUUDLUDRRURDDUUURRLRRDDLULLLDLRULRRRLDRRURRURRUUDDDLDRRURLRRRRDLDLDUDURRDDLLLUULDDLRLURLRRURDRUULDDDUDRDRUDRRLRLLLLLURDULDUDRLULDRLUULUDDDDUDDRDDLDDRLLRULRRURDDDRDDLDLULRDDRRURRUDRDDDDRURDRRURUUDUDDUURULLDRDULURUDUD";
// static INPUT : &'static str = "ULL
// RRDDD
// LURDL
// UUUUD";

type Key = [usize; 2];
type Keypad = Vec<Vec<char>>;

#[derive(Debug)]
enum Direction {
  Up, Left, Down, Right
}

fn get(keypad: &Keypad, key: Key) -> char {
  return keypad[key[0]][key[1]];
}


impl Direction {
  fn shift(&self, key: Key, keypad: &Keypad) -> Key {
    match *self {
      Direction::Up => if get(keypad, [key[0]-1, key[1]]) == ' ' {
        return key;
      } else {
        return [key[0]-1, key[1]];
      },
      Direction::Left => if get(keypad, [key[0], key[1]-1]) == ' ' {
        return key;
      } else {
        return [key[0], key[1]-1];
      },
      Direction::Down => if get(keypad, [key[0]+1, key[1]]) == ' ' {
        return key;
      } else {
        return [key[0]+1, key[1]];
      },
      Direction::Right => if get(keypad, [key[0], key[1]+1]) == ' ' {
        return key;
      } else {
        return [key[0], key[1]+1];
      },
    }
  }
}

use std::str::FromStr;
impl FromStr for Direction {
  type Err = ();

  fn from_str(s: &str) -> Result<Direction, ()> {
    match s {
      "U" => Ok(Direction::Up),
      "L" => Ok(Direction::Left),
      "D" => Ok(Direction::Down),
      "R" => Ok(Direction::Right),
      _ => Err(()),
    }
  }
}

fn handle_direction(key: Key, keypad: &Keypad, next: char) ->Key {
  let direction: Direction = next.to_string().parse().unwrap();
  // println!("{:?}, {:?}", direction, direction.shift(key));
  return direction.shift(key, keypad);
}

fn parse_line(key: &mut Key, keypad: &Keypad, line: String) {
  for direction in line.chars() {
    *key = handle_direction(*key, keypad, direction);
  }
  print!("{}", get(keypad, *key));
}

//-----------------------------------------------------
// Questions.

fn a() {
  let keypad : Keypad = vec![
  vec![' ',' ',' ',' ',' '],
  vec![' ','1','2','3',' '],
  vec![' ','4','5','6',' '],
  vec![' ','7','8','9',' '],
  vec![' ',' ',' ',' ',' ']];


  let mut key: Key = [2,2];

  print!("2A: Result = ");
  for line in INPUT.lines() {
    parse_line(&mut key, &keypad, String::from(line));
  }
  println!("");
}

fn b() {
  let keypad : Keypad = vec![
  vec![' ',' ',' ',' ',' ',' ',' '],
  vec![' ',' ',' ','1',' ',' ',' '],
  vec![' ',' ','2','3','4',' ',' '],
  vec![' ','5','6','7','8','9',' '],
  vec![' ',' ','A','B','C',' ',' '],
  vec![' ',' ',' ','D',' ',' ',' '],
  vec![' ',' ',' ',' ',' ',' ',' '],
  ];


  let mut key: Key = [3,1];

  print!("2B: Result = ");
  for line in INPUT.lines() {
    parse_line(&mut key, &keypad, String::from(line));
  }
  println!("");
}